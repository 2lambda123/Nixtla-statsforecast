---

title: Models


keywords: fastai
sidebar: home_sidebar

summary: "Uniserie models implementations."
description: "Uniserie models implementations."
nb_path: "nbs/models.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/models.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="ARIMA-methods">ARIMA methods<a class="anchor-link" href="#ARIMA-methods"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="AutoARIMA" class="doc_header"><code>class</code> <code>AutoARIMA</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L30" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>AutoARIMA</code>(<strong><code>season_length</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>approximation</code></strong>:<code>bool</code>=<em><code>False</code></em>) :: <code>_TS</code></p>
</blockquote>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>season_length</code></strong></td>
<td><code>int</code></td>
<td><code>1</code></td>
<td>Number of observations per cycle</td>
</tr>
<tr>
<td><strong><code>approximation</code></strong></td>
<td><code>bool</code></td>
<td><code>False</code></td>
<td><em>No Content</em></td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <a href="/statsforecast/models.html#AutoARIMA"><code>AutoARIMA</code></a> class instantiates the model.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">arima</span> <span class="o">=</span> <span class="n">AutoARIMA</span><span class="p">(</span><span class="n">season_length</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="AutoARIMA.forecast" class="doc_header"><code>AutoARIMA.forecast</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L77" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>AutoARIMA.forecast</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>h</code></strong>:<code>int</code>, <strong><code>X</code></strong>:<code>ndarray</code>=<em><code>None</code></em>, <strong><code>X_future</code></strong>:<code>ndarray</code>=<em><code>None</code></em>, <strong><code>level</code></strong>:<code>Optional</code>[<code>Tuple</code>[<code>int</code>]]=<em><code>None</code></em>, <strong><code>fitted</code></strong>:<code>bool</code>=<em><code>False</code></em>)</p>
</blockquote>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>y</code></strong></td>
<td><code>ndarray</code></td>
<td></td>
<td><em>No Content</em></td>
</tr>
<tr>
<td><strong><code>h</code></strong></td>
<td><code>int</code></td>
<td></td>
<td><em>No Content</em></td>
</tr>
<tr>
<td><strong><code>X</code></strong></td>
<td><code>ndarray</code></td>
<td><code>None</code></td>
<td><em>No Content</em></td>
</tr>
<tr>
<td><strong><code>X_future</code></strong></td>
<td><code>ndarray</code></td>
<td><code>None</code></td>
<td><em>No Content</em></td>
</tr>
<tr>
<td><strong><code>level</code></strong></td>
<td><code>typing.Union[typing.Tuple[int], NoneType]</code></td>
<td><code>None</code></td>
<td>level</td>
</tr>
<tr>
<td><strong><code>fitted</code></strong></td>
<td><code>bool</code></td>
<td><code>False</code></td>
<td>return fitted values?</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Once <a href="/statsforecast/models.html#AutoARIMA"><code>AutoARIMA</code></a> is instantiated, you can make forecasts directly using the <a href="/statsforecast/models.html#AutoARIMA.forecast"><code>AutoARIMA.forecast</code></a> method. The purpose of this method is to avoid computational burden due to object storage. This method can be thought of as a <code>fit_predict</code> without storing information. This method assumes you know the forecast horizon in advance. Observe that the method a returns a <code>dict</code> object instead of a numpy array.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">statsforecast.utils</span> <span class="kn">import</span> <span class="n">AirPassengers</span> <span class="k">as</span> <span class="n">ap</span>
<span class="n">arima</span><span class="o">.</span><span class="n">forecast</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">ap</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="AutoARIMA.fit" class="doc_header"><code>AutoARIMA.fit</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L43" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>AutoARIMA.fit</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>X</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>)</p>
</blockquote>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>y</code></strong></td>
<td><code>ndarray</code></td>
<td></td>
<td>time series</td>
</tr>
<tr>
<td><strong><code>X</code></strong></td>
<td><code>typing.Union[numpy.ndarray, NoneType]</code></td>
<td><code>None</code></td>
<td><em>No Content</em></td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If you want to store the fitted model for future analysis, you can use the <a href="/statsforecast/models.html#AutoARIMA.fit"><code>AutoARIMA.fit</code></a> method.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">arima</span> <span class="o">=</span> <span class="n">arima</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">ap</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="AutoARIMA.predict" class="doc_header"><code>AutoARIMA.predict</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L58" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>AutoARIMA.predict</code>(<strong><code>h</code></strong>:<code>int</code>, <strong><code>X</code></strong>:<code>ndarray</code>=<em><code>None</code></em>, <strong><code>level</code></strong>:<code>Optional</code>[<code>Tuple</code>[<code>int</code>]]=<em><code>None</code></em>)</p>
</blockquote>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>h</code></strong></td>
<td><code>int</code></td>
<td></td>
<td>Forecast horizon</td>
</tr>
<tr>
<td><strong><code>X</code></strong></td>
<td><code>ndarray</code></td>
<td><code>None</code></td>
<td><em>No Content</em></td>
</tr>
<tr>
<td><strong><code>level</code></strong></td>
<td><code>typing.Union[typing.Tuple[int], NoneType]</code></td>
<td><code>None</code></td>
<td><em>No Content</em></td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can compute forecasts for the fitted model using <a href="/statsforecast/models.html#AutoARIMA.predict"><code>AutoARIMA.predict</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">arima</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">h</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="AutoARIMA.predict_in_sample" class="doc_header"><code>AutoARIMA.predict_in_sample</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L74" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>AutoARIMA.predict_in_sample</code>()</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To obtain the fitted values, you can use <a href="/statsforecast/models.html#AutoARIMA.predict_in_sample"><code>AutoARIMA.predict_in_sample</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">arima</span><span class="o">.</span><span class="n">predict_in_sample</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Model-Description">Model Description<a class="anchor-link" href="#Model-Description"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Auto ARIMA</strong>: Automatically selects the best ARIMA (AutoRegressive Integrated Moving Average) model using an information criterion. Default is the corrected Akaike Information Criterion (AICc). Information criterions are tests used to check how well a model fits the data it is trying to describe.</p>
<p>The ARIMA models are based in the autocorrelations in the data and the autocorrelations of the forecast errors. Every model has three components: AR, I, and MA.</p>
<p>An AR(p) model captures the autocorrelations in the data at lags $1,2,\dots p$.</p>
<p>{% raw %}
$$y_t = \beta_0+\beta_1y_{t-1}+\beta_2y_{t-2}+\dots+\beta_py{t_p}+\epsilon_t$$
{% endraw %}</p>
<p>If the autocorrelations of the forecast errors are added up to lag $q$, an ARMA(p,q) model is obtained.</p>
<p>{% raw %}
$$y_t = \beta_0+\beta_1y_{t-1}+\beta_2y_{t-2}+\dots+\beta_py{t_p} + \epsilon_t+\theta_1 \epsilon_{t-1}+\theta_2\epsilon_{t-2}+\dots\theta_q\epsilon_{t-q}$$
{% endraw %}</p>
<p>The last component of an ARIMA model is the integrated (I) part, which is a differencing operation. The order of differencing, denoted by $d$, indicates how many rounds of lag-1 differencing are performed.</p>
<p>ARIMA models requiere the user to select $p$, $q$, and $d$. The values for $\beta_i, i=1,2,\dots,p$ and $\theta_j, j=1,2,\dots,q$ are then estimated. Auto ARIMA automatically makes this selection, searching over a range of possible values for $p$, $q$, and $d$, and then choosing the best model using an information criterion.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Exponential-smoothing-methods">Exponential smoothing methods<a class="anchor-link" href="#Exponential-smoothing-methods"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ETS" class="doc_header"><code>class</code> <code>ETS</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L107" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ETS</code>(<strong><code>season_length</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>model</code></strong>:<code>str</code>=<em><code>'ZZZ'</code></em>) :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Error, Trend, and Seasonality</strong>: Statistical models for exponential smoothing. These models are stochastic data generating processes than can produce complete forecast distributions. Each model consists of a set of equations to describe the observed data and the unobserved components or states, which are level, trend, and seasonal. Errors can be either additive or multiplicative. The notation ETS(Z,Z,Z) is used to describe the ETS model being used, where Z can take one of the following values.</p>
<table>
<thead><tr>
<th>Notation</th>
</tr>
</thead>
<tbody>
<tr>
<td>N = None</td>
<td></td>
</tr>
<tr>
<td>A = Additive</td>
<td></td>
</tr>
<tr>
<td>Ad = Additive (damped)</td>
<td></td>
</tr>
<tr>
<td>M = Multiplicative</td>
<td></td>
</tr>
</tbody>
</table>
<p>The possibilities for each state are shown below.</p>
<table>
<thead><tr>
<th>State</th>
<th>Possible values </th>
</tr>
</thead>
<tbody>
<tr>
<td>Error</td>
<td>A, M</td>
</tr>
<tr>
<td>Trend</td>
<td>N, A, Ad</td>
</tr>
<tr>
<td>Seasonal</td>
<td>N, A, M</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SimpleExponentialSmoothing" class="doc_header"><code>class</code> <code>SimpleExponentialSmoothing</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L260" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SimpleExponentialSmoothing</code>(<strong><code>alpha</code></strong>:<code>float</code>) :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Simple (or single) exponential smoothing</strong>: Uses a weighted average of all past observations where the weights decrease exponentially into the past. Suitable for data with no clear trend or seasonality. Assuming there are $t$ observations, the one-step forecast is given by</p>
<p>{% raw %}
$$\hat{y}_{t+1}= \alpha y_{t} + \alpha(1-\alpha)y_{t-1} + \alpha(1-\alpha)^2 y_{t-2} \dots$$
{% endraw %}</p>
<p>which can also be written as</p>
<p>{% raw %}
$$\hat{y}_{t+1} = \alpha y_t + \alpha(1-\alpha) \hat{y}_{t-1}$$
{% endraw %}</p>
<p>The rate $0 \leq \alpha \leq 1$ at which the weights decrease is called the smoothing parameter. When $\alpha = 1$, SES is equal to the naive method.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SimpleExponentialSmoothingOptimized" class="doc_header"><code>class</code> <code>SimpleExponentialSmoothingOptimized</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L304" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SimpleExponentialSmoothingOptimized</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Simple exponential smoothing optimized</strong>: A version of SES where the smoothing parameter $\alpha$ is chosen automatically by minimizing the mean squared error of the fit.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SeasonalExponentialSmoothing" class="doc_header"><code>class</code> <code>SeasonalExponentialSmoothing</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L356" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SeasonalExponentialSmoothing</code>(<strong><code>season_length</code></strong>:<code>int</code>, <strong><code>alpha</code></strong>:<code>float</code>) :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Seasonal exponential smoothing</strong>: A seasonal version of exponential smoothing.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SeasonalExponentialSmoothingOptimized" class="doc_header"><code>class</code> <code>SeasonalExponentialSmoothingOptimized</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L417" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SeasonalExponentialSmoothingOptimized</code>(<strong><code>season_length</code></strong>:<code>int</code>) :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Seasonal SES optimized</strong>: A seasonal version of SES optimized</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Simple-methods">Simple methods<a class="anchor-link" href="#Simple-methods"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="HistoricAverage" class="doc_header"><code>class</code> <code>HistoricAverage</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L471" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>HistoricAverage</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Historic average:</strong> Also known as mean method. Uses a simple average of all past observations. Assuming there are $t$ observations, the one-step forecast is given by</p>
<p>{% raw %}
$$ \hat{y}_{t+1} = \frac{1}{t} \sum_{j=1}^t y_j $$
{% endraw %}</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Naive" class="doc_header"><code>class</code> <code>Naive</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L516" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Naive</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Naive</strong>: A random walk model, defined as</p>
<p>{% raw %}
$$ \hat{y}_{t+1} = y_t $$
{% endraw %}</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RandomWalkWithDrift" class="doc_header"><code>class</code> <code>RandomWalkWithDrift</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L565" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RandomWalkWithDrift</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Random walk with drift</strong>: A variation of the naive method allows the forecasts to change over time. The amout of change, called drift, is the average change seen in the historical data.</p>
<p>{% raw %}
$$ \hat{y}_{t+1} = y_t+\frac{1}{t-1}\sum_{j=1}^t (y_j-y_{j-1}) = y_t+ \frac{y_t-y_1}{t-1} $$
{% endraw %}</p>
<p>From the previous equation, we can see that this is equivalent to extrapolating a line between the first and the last observation.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SeasonalNaive" class="doc_header"><code>class</code> <code>SeasonalNaive</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L620" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SeasonalNaive</code>(<strong><code>season_length</code></strong>:<code>int</code>) :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Seasonal naive</strong>: Similar to the naive method, but uses the last known observation of the same period (e.g. the same month of the previous year) in order to capture seasonal variations.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="WindowAverage" class="doc_header"><code>class</code> <code>WindowAverage</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L675" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>WindowAverage</code>(<strong><code>window_size</code></strong>:<code>int</code>) :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Window average</strong>: Uses the average of the last $k$ observations, with $k$ the length of the window. Wider windows will capture global trends, while narrow windows will reveal local trends. The length of the window selected should take into account the importance of past observations and how fast the series changes.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SeasonalWindowAverage" class="doc_header"><code>class</code> <code>SeasonalWindowAverage</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L727" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SeasonalWindowAverage</code>(<strong><code>season_length</code></strong>:<code>int</code>, <strong><code>window_size</code></strong>:<code>int</code>) :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Seasonal window average</strong>: An average of the last $k$ observations of the same period, with $k$ the length of the window.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Sparse-or-intermittent-series">Sparse or intermittent series<a class="anchor-link" href="#Sparse-or-intermittent-series"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Sparse or intermittent series are series with very few non-zero observations. They are notoriously hard to forecast, and so, different methods have been developed especifically for them. Before the development of Croston's method and its variants, SES was usually used to forecast them.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ADIDA" class="doc_header"><code>class</code> <code>ADIDA</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L790" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ADIDA</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Aggregate-Dissagregate Intermittent Demand Approach</strong>: Uses temporal aggregation to reduce the number of zero observations. Once the data has been agregated, it uses the optimized SES to generate the forecasts at the new level. It then breaks down the forecast to the original level using equal weights.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CrostonClassic" class="doc_header"><code>class</code> <code>CrostonClassic</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L838" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CrostonClassic</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Croston classic</strong>: A method to forecast time series that exhibit intermittent demand. It decomposes the original time series into a non-zero demand size $z_t$ and inter-demand intervals $p_t$. Then the forecast is given by</p>
$$ \hat{y}_t = \frac{\hat{z}_t}{\hat{p}_t} $$<p></p>
<p>where $\hat{z}_t$ and $\hat{p}_t$ are forecasted using SES. The smoothing parameter of both components is set equal to 0.1</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CrostonOptimized" class="doc_header"><code>class</code> <code>CrostonOptimized</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L885" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CrostonOptimized</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Croston Optimized</strong>: A variation of the classic Croston's method where the smooting paramater is optimally selected from the range $[0.1,0.3]$. Both the non-zero demand $z_t$ and the inter-demand intervals $p_t$ are smoothed separately, so their smoothing parameters can be different.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CrostonSBA" class="doc_header"><code>class</code> <code>CrostonSBA</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L929" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CrostonSBA</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Croston with Syntetos-Boylan Approximation</strong>: A variation of the classic Croston's method that uses a debiasing factor, so that the forecast is given by</p>
$$ \hat{y}_t = 0.95  \frac{\hat{z}_t}{\hat{p}_t} $$<p></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="IMAPA" class="doc_header"><code>class</code> <code>IMAPA</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L984" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>IMAPA</code>() :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Intermittent Multiple Aggregation Prediction Algorithm</strong>: Similar to ADIDA, but instead of using a single aggregation level, it considers multiple in order to capture different dynamics of the data. Uses the optimized SES to generate the forecasts at the new levels and then combines them using a simple average.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="TSB" class="doc_header"><code>class</code> <code>TSB</code><a href="https://github.com/Nixtla/statsforecast/tree/main/statsforecast/models.py#L1036" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>TSB</code>(<strong><code>alpha_d</code></strong>:<code>float</code>, <strong><code>alpha_p</code></strong>:<code>float</code>) :: <code>_TS</code></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Teunter-Syntetos-Babai</strong>: A modification of Croston's method that replaces the inter-demand intervals with the demand probability $d_t$, which is defined as follows.</p>
$$
d_t = \begin{cases}
    1  &amp; \text{if demand occurs at time t}\\ 
    0 &amp; \text{otherwise.}
\end{cases}
$$<p>Hence, the forecast is given by</p>
<p>{% raw %}
$$\hat{y}_t= \hat{d}_t\hat{z_t}$$
{% endraw %}</p>
<p>Both $d_t$ and $z_t$ are forecasted using SES. The smooting paramaters of each may differ, like in the optimized Croston's method.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="References">References<a class="anchor-link" href="#References"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="General"><strong>General</strong><a class="anchor-link" href="#General"> </a></h4><ul>
<li><p>Hyndman, R.J., &amp; Athanasopoulos, G. (2021) Forecasting: principles and practice, 3rd edition, OTexts: Melbourne, Australia. <a href="https://otexts.com/fpp3/">OTexts.com/fpp3</a>. Accessed on July 2022.</p>
</li>
<li><p>Shmueli, G., &amp; Lichtendahl Jr, K. C. (2016). Practical time series forecasting with r: A hands-on guide. Axelrod Schnall Publishers.</p>
</li>
</ul>
<h4 id="For-sparse-or-intermittent-series"><strong>For sparse or intermittent series</strong><a class="anchor-link" href="#For-sparse-or-intermittent-series"> </a></h4><ul>
<li><a href="https://link.springer.com/article/10.1057/jors.1972.50">Croston, J. D. (1972). Forecasting and stock control for intermittent demands. Journal of the Operational Research Society, 23(3), 289-303.</a></li>
</ul>
<ul>
<li><p><a href="https://researchportal.bath.ac.uk/en/publications/an-aggregate-disaggregate-intermittent-demand-approach-adida-to-f">Nikolopoulos, K., Syntetos, A. A., Boylan, J. E., Petropoulos, F., &amp; Assimakopoulos, V. (2011). An aggregate–disaggregate intermittent demand approach (ADIDA) to forecasting: an empirical proposition and analysis. Journal of the Operational Research Society, 62(3), 544-554.</a></p>
</li>
<li><p><a href="https://www.academia.edu/1527250/The_accuracy_of_intermittent_demand_estimates">Syntetos, A. A., &amp; Boylan, J. E. (2005). The accuracy of intermittent demand estimates. International Journal of forecasting, 21(2), 303-314.</a></p>
</li>
<li><p>Syntetos, A. A., &amp; Boylan, J. E. (2021). Intermittent demand forecasting: Context, methods and applications. John Wiley &amp; Sons.</p>
</li>
<li><p><a href="https://www.sciencedirect.com/science/article/abs/pii/S0377221711004437">Teunter, R. H., Syntetos, A. A., &amp; Babai, M. Z. (2011). Intermittent demand: Linking forecasting to inventory obsolescence. European Journal of Operational Research, 214(3), 606-615.</a></p>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">statsforecast.utils</span> <span class="kn">import</span> <span class="n">AirPassengers</span> <span class="k">as</span> <span class="n">ap</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">arima</span> <span class="o">=</span> <span class="n">AutoARIMA</span><span class="p">(</span><span class="n">season_length</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">arima</span> <span class="o">=</span> <span class="n">arima</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
<span class="n">arima</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ets</span> <span class="o">=</span> <span class="n">ETS</span><span class="p">(</span><span class="n">season_length</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ets</span> <span class="o">=</span> <span class="n">ets</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
<span class="n">ets</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>External regressors</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">drift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ap</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">drift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">drift</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">newdrift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ap</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ap</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">newxreg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">newdrift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">newdrift</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">arima</span> <span class="o">=</span> <span class="n">AutoARIMA</span><span class="p">(</span><span class="n">season_length</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">arima</span> <span class="o">=</span> <span class="n">arima</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">ap</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">arima</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">newxreg</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Confidence intervals</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">arima</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">newxreg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">95</span><span class="p">)))</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

