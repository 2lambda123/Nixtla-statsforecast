# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/models.ipynb (unless otherwise specified).

__all__ = ['auto_arima', 'ets', 'ses', 'ses_optimized', 'seasonal_exponential_smoothing', 'seasonal_ses_optimized',
           'historic_average', 'naive', 'random_walk_with_drift', 'seasonal_naive', 'window_average',
           'seasonal_window_average', 'adida', 'croston_classic', 'croston_optimized', 'croston_sba', 'imapa', 'tsb']

# Cell
from itertools import count
from numbers import Number
from typing import Collection, List, Optional, Sequence, Tuple

import numpy as np
import pandas as pd
from numba import njit
from scipy.optimize import minimize

from .arima import auto_arima_f, forecast_arima, fitted_arima
from .ets import ets_f, forecast_ets

# Cell
def auto_arima(X: np.ndarray, # time series
               h: int, # forecasting horizon
               future_xreg=None, #future regressors
               fitted: bool=False, # fitted values
               season_length: int=1, # season_length
               approximation: bool=False, # approximation
               level: Optional[Tuple[int]] = None # level
    ) -> np.ndarray:
    y = X[:, 0] if X.ndim == 2 else X
    xreg = X[:, 1:] if (X.ndim == 2 and X.shape[1] > 1) else None
    with np.errstate(invalid='ignore'):
        mod = auto_arima_f(
            y,
            xreg=xreg,
            period=season_length,
            approximation=approximation,
            allowmean=False, allowdrift=False #not implemented yet
        )
    fcst = forecast_arima(mod, h, xreg=future_xreg, level=level)
    mean = fcst['mean']
    if fitted:
        return {'mean': mean, 'fitted': fitted_arima(mod)}
    if level is None:
        return {'mean': mean}
    return {
        'mean': mean,
        **{f'lo-{l}': fcst['lower'][f'{l}%'] for l in reversed(level)},
        **{f'hi-{l}': fcst['upper'][f'{l}%'] for l in level},
    }

# Cell
def ets(X: np.ndarray, # time series
        h: int, # forecasting horizon
        future_xreg=None, # future regressors
        fitted: bool = False, # fitted values
        season_length: int = 1, # season length
        model: str = 'ZZZ' # model type
    )-> np.ndarray:
    y = X[:, 0] if X.ndim == 2 else X
    xreg = X[:, 1:] if (X.ndim == 2 and X.shape[1] > 1) else None
    mod = ets_f(y, m=season_length, model=model)
    fcst = forecast_ets(mod, h)
    keys = ['mean']
    if fitted:
        keys.append('fitted')
    return {key: fcst[key] for key in keys}

# Cell
@njit
def _ses_fcst_mse(x: np.ndarray, alpha: float) -> Tuple[float, float]:
    """Perform simple exponential smoothing on a series.

    This function returns the one step ahead prediction
    as well as the mean squared error of the fit.
    """
    smoothed = x[0]
    n = x.size
    mse = 0.
    fitted = np.full(n, np.nan, np.float32)

    for i in range(1, n):
        smoothed = (alpha * x[i - 1] + (1 - alpha) * smoothed).item()
        error = x[i] - smoothed
        mse += error * error
        fitted[i] = smoothed

    mse /= n
    forecast = alpha * x[-1] + (1 - alpha) * smoothed
    return forecast, mse, fitted


def _ses_mse(alpha: float, x: np.ndarray) -> float:
    """Compute the mean squared error of a simple exponential smoothing fit."""
    _, mse, _ = _ses_fcst_mse(x, alpha)
    return mse


@njit
def _ses_forecast(x: np.ndarray, alpha: float) -> float:
    """One step ahead forecast with simple exponential smoothing."""
    forecast, _, fitted = _ses_fcst_mse(x, alpha)
    return forecast, fitted


@njit
def _demand(x: np.ndarray) -> np.ndarray:
    """Extract the positive elements of a vector."""
    return x[x > 0]


@njit
def _intervals(x: np.ndarray) -> np.ndarray:
    """Compute the intervals between non zero elements of a vector."""
    y = []

    ctr = 1
    for val in x:
        if val == 0:
            ctr += 1
        else:
            y.append(ctr)
            ctr = 1

    y = np.array(y)
    return y


@njit
def _probability(x: np.ndarray) -> np.ndarray:
    """Compute the element probabilities of being non zero."""
    return (x != 0).astype(np.int32)


def _optimized_ses_forecast(
        x: np.ndarray,
        bounds: Sequence[Tuple[float, float]] = [(0.1, 0.3)]
    ) -> float:
    """Searches for the optimal alpha and computes SES one step forecast."""
    alpha = minimize(
        fun=_ses_mse,
        x0=(0,),
        args=(x,),
        bounds=bounds,
        method='L-BFGS-B'
    ).x[0]
    forecast, fitted = _ses_forecast(x, alpha)
    return forecast, fitted


@njit
def _chunk_sums(array: np.ndarray, chunk_size: int) -> np.ndarray:
    """Splits an array into chunks and returns the sum of each chunk."""
    n = array.size
    n_chunks = n // chunk_size
    sums = np.empty(n_chunks)
    for i, start in enumerate(range(0, n, chunk_size)):
        sums[i] = array[start : start + chunk_size].sum()
    return sums

# Internal Cell
#@njit
def ses_(X: np.ndarray, # time series
        h: int, # forecasting horizon
        future_xreg: np.ndarray, # future regressors
        fitted: bool, # fitted values
        alpha: float): # smoothing parameter
    y = X[:, 0] if X.ndim == 2 else X
    fcst, _, fitted_vals = _ses_fcst_mse(y, alpha)
    mean = np.full(h, fcst, np.float32)
    fcst = {'mean': mean}
    if fitted:
        fcst['fitted'] = fitted_vals
    return fcst

# Cell
def ses(X: np.ndarray, # time series
        h: int, # forecasting horizon
        future_xreg: np.ndarray, # future regressors
        fitted: bool, # fitted values
        alpha: float): # smoothing parameter

    return ses_(X, h, future_xreg, fitted, alpha)

# Cell
def ses_optimized(X: np.ndarray, # time series
                  h: int, # forecasting horizon
                  future_xreg: np.ndarray, # future regressors
                  fitted: bool): # fitted values
    y = X[:, 0] if X.ndim == 2 else X
    fcst, res = _optimized_ses_forecast(y, [(0.01, 0.99)])
    mean = np.full(h, fcst, np.float32)
    fcst = {'mean': mean}
    if fitted:
        fcst['fitted'] = fitted
    return fcst

# Internal Cell
@njit
def seasonal_exponential_smoothing_(X: np.ndarray, # time series
                                   h: int, # forecasting horizon
                                   future_xreg: np.ndarray, # future regressors
                                   fitted: bool, # fitted values
                                   season_length: int, # length of season
                                   alpha: float): # smoothing parameter
    y = X[:, 0] if X.ndim == 2 else X
    if y.size < season_length:
        return {'mean': np.full(h, np.nan, np.float32)}
    season_vals = np.empty(season_length, np.float32)
    fitted_vals = np.full(y.size, np.nan, np.float32)
    for i in range(season_length):
        season_vals[i], fitted_vals[i::season_length] = _ses_forecast(y[i::season_length], alpha)
    out = np.empty(h, np.float32)
    for i in range(h):
        out[i] = season_vals[i % season_length]
    fcst = {'mean': out}
    if fitted:
        fcst['fitted'] = fitted_vals
    return fcst

# Cell
#@njit
def seasonal_exponential_smoothing(X: np.ndarray, # time series
                                   h: int, # forecasting horizon
                                   future_xreg: np.ndarray, # future regressors
                                   fitted: bool, # fitted values
                                   season_length: int, # length of season
                                   alpha: float): # smoothing parameter

    return seasonal_exponential_smoothing_(X,h,future_xreg,fitted,season_length,alpha)

# Cell
def seasonal_ses_optimized(X: np.ndarray, # time series
                           h: int, # forecasting horizon
                           future_xreg: np.ndarray, # future regressors
                           fitted: bool , # fitted values
                           season_length: int): # season length
    y = X[:, 0] if X.ndim == 2 else X
    if y.size < season_length:
        return {'mean': np.full(h, np.nan, np.float32)}
    season_vals = np.empty(season_length, np.float32)
    fitted_vals = np.full(y.size, np.nan, np.float32)
    for i in range(season_length):
        season_vals[i], fitted_vals[i::season_length] = _optimized_ses_forecast(y[i::season_length], [(0.01, 0.99)])
    out = np.empty(h, np.float32)
    for i in range(h):
        out[i] = season_vals[i % season_length]
    fcst = {'mean': out}
    if fitted:
        fcst['fitted'] = fitted_vals
    return fcst

# Internal Cell
@njit
def historic_average_(X: np.ndarray, # time series
                     h: int, # forecasting horizon
                     future_xreg: np.ndarray, # future regressors
                     fitted: bool): # fitted values
    y = X[:, 0] if X.ndim == 2 else X
    mean = np.repeat(y.mean(), h)
    fcst = {'mean': mean}
    if fitted:
        fitted_vals = np.full(y.size, np.nan, y.dtype)
        fitted_vals[1:] = y.cumsum()[:-1] / np.arange(1, y.size)
        fcst['fitted'] = fitted_vals
    return fcst

# Cell
#@njit
def historic_average(X: np.ndarray, # time series
                     h: int, # forecasting horizon
                     future_xreg: np.ndarray, # future regressors
                     fitted: bool): # fitted values

    return historic_average_(X, h, future_xreg, fitted)

# Internal Cell
@njit
def naive_(X: np.ndarray, # time series
          h: int, # forecasting horizon
          future_xreg: np.ndarray, # future regressors
          fitted: bool): # fitted values
    y = X[:, 0] if X.ndim == 2 else X
    mean = np.repeat(y[-1], h).astype(np.float32)
    if fitted:
        fitted_vals = np.full(y.size, np.nan, np.float32)
        fitted_vals[1:] = np.roll(y, 1)[1:]
        return {'mean': mean, 'fitted': fitted_vals}
    return {'mean': mean}

# Cell
#@njit
def naive(X: np.ndarray, # time series
          h: int, # forecasting horizon
          future_xreg: np.ndarray, # future regressors
          fitted: bool): # fitted values

    return naive_(X, h, future_xreg, fitted)

# Internal Cell
@njit
def random_walk_with_drift_(X: np.ndarray, # time series
                           h: int, # forecasting horizon
                           future_xreg: np.ndarray, # future regressors
                           fitted: bool): # fitted values
    y = X[:, 0] if X.ndim == 2 else X
    slope = (y[-1] - y[0]) / (y.size - 1)
    mean = slope * (1 + np.arange(h)) + y[-1]
    fcst = {'mean': mean.astype(np.float32)}
    if fitted:
        fitted_vals = np.full(y.size, np.nan, dtype=np.float32)
        fitted_vals[1:] = (slope + y[:-1]).astype(np.float32)
        fcst['fitted'] = fitted_vals
    return fcst

# Cell
#@njit
def random_walk_with_drift(X: np.ndarray, # time series
                           h: int, # forecasting horizon
                           future_xreg: np.ndarray, # future regressors
                           fitted: bool): # fitted values

    return random_walk_with_drift_(X, h, future_xreg, fitted)

# Internal Cell
@njit
def seasonal_naive_(X: np.ndarray, # time series
                   h: int, # forecasting horizon
                   future_xreg: np.ndarray, #future regressors
                   fitted: bool, #fitted values
                   season_length: int): # season length
    y = X[:, 0] if X.ndim == 2 else X
    if y.size < season_length:
        return {'mean': np.full(h, np.nan, np.float32)}
    season_vals = np.empty(season_length, np.float32)
    fitted_vals = np.full(y.size, np.nan, np.float32)
    for i in range(season_length):
        s_naive = naive_(y[i::season_length], 1, None, fitted)
        season_vals[i] = s_naive['mean'].item()
        if fitted:
            fitted_vals[i::season_length] = s_naive['fitted']
    out = np.empty(h, np.float32)
    for i in range(h):
        out[i] = season_vals[i % season_length]
    fcst = {'mean': out}
    if fitted:
        fcst['fitted'] = fitted_vals
    return fcst

# Cell
#@njit
def seasonal_naive(X: np.ndarray, # time series
                   h: int, # forecasting horizon
                   future_xreg: np.ndarray, #future regressors
                   fitted: bool, #fitted values
                   season_length: int): # length of season

    return seasonal_naive_(X, h, future_xreg, fitted, season_length)

# Internal Cell
@njit
def window_average_(X: np.ndarray, # time series
                   h: int, # forecasting horizon
                   future_xreg: np.ndarray, # future regressors
                   fitted: bool, # fitted values
                   window_size: int): # window size
    if fitted:
        raise NotImplementedError('return fitted')
    y = X[:, 0] if X.ndim == 2 else X
    if y.size < window_size:
        return {'mean': np.full(h, np.nan, np.float32)}
    wavg = y[-window_size:].mean()
    mean = np.repeat(wavg, h)
    return {'mean': mean}

# Cell
#@njit
def window_average(X: np.ndarray, # time series
                   h: int, # forecasting horizon
                   future_xreg: np.ndarray, # future regressors
                   fitted: bool, # fitted values
                   window_size: int): # window size

    return window_average_(X, h, future_xreg, fitted, window_size)

# Internal Cell
@njit
def seasonal_window_average_(
    X: np.ndarray,
    h: int,
    future_xreg: np.ndarray,
    fitted: bool,
    season_length: int,
    window_size: int,
) -> np.ndarray:
    if fitted:
        raise NotImplementedError('return fitted')
    y = X[:, 0] if X.ndim == 2 else X
    min_samples = season_length * window_size
    if y.size < min_samples:
        return {'mean': np.full(h, np.nan, np.float32)}
    season_avgs = np.zeros(season_length, np.float32)
    for i, value in enumerate(y[-min_samples:]):
        season = i % season_length
        season_avgs[season] += value / window_size
    out = np.empty(h, np.float32)
    for i in range(h):
        out[i] = season_avgs[i % season_length]
    return {'mean': out}

# Cell
#@njit
def seasonal_window_average(
    X: np.ndarray, # time series
    h: int, # forecasting horizon
    future_xreg: np.ndarray, # future regressors
    fitted: bool, # fitted values
    season_length: int, # length of season
    window_size: int, # window size
) -> np.ndarray:

    return seasonal_window_average_(X,h,future_xreg, fitted, season_length, window_size)

# Cell
def adida(X: np.ndarray, # time series
          h: int, # forecasting horizon
          future_xreg: np.ndarray, # future regressors
          fitted: bool): # fitted values
    if fitted:
        raise NotImplementedError('return fitted')
    y = X[:, 0] if X.ndim == 2 else X
    if (y == 0).all():
        return {'mean': np.repeat(np.float32(0), h)}
    y_intervals = _intervals(y)
    mean_interval = y_intervals.mean()
    aggregation_level = round(mean_interval)
    lost_remainder_data = len(y) % aggregation_level
    y_cut = y[lost_remainder_data:]
    aggregation_sums = _chunk_sums(y_cut, aggregation_level)
    sums_forecast, _ = _optimized_ses_forecast(aggregation_sums)
    forecast = sums_forecast / aggregation_level
    mean = np.repeat(forecast, h)
    return {'mean': mean}

# Internal Cell
@njit
def croston_classic_(X: np.ndarray, # time series
                    h: int, # forecasting horizon
                    future_xreg: np.ndarray, # future regressors
                    fitted: bool): # fitted values
    if fitted:
        raise NotImplementedError('return fitted')
    y = X[:, 0] if X.ndim == 2 else X
    yd = _demand(y)
    yi = _intervals(y)
    ydp, _ = _ses_forecast(yd, 0.1)
    yip, _ = _ses_forecast(yi, 0.1)
    mean = ydp / yip
    return {'mean': mean}

# Cell
#@njit
def croston_classic(X: np.ndarray, # time series
                    h: int, # forecasting horizon
                    future_xreg: np.ndarray, # future regressors
                    fitted: bool): # fitted values

    return croston_classic_(X, h, future_xreg, fitted)

# Cell
def croston_optimized(X: np.ndarray, # time series
                      h: int, # forecasting horizon
                      future_xreg: np.ndarray, # future regressors
                      fitted: bool): # fitted values
    if fitted:
        raise NotImplementedError('return fitted')
    y = X[:, 0] if X.ndim == 2 else X
    yd = _demand(y)
    yi = _intervals(y)
    ydp, _ = _optimized_ses_forecast(yd)
    yip, _ = _optimized_ses_forecast(yi)
    mean = ydp / yip
    return {'mean': mean}

# Internal Cell
@njit
def croston_sba_(X: np.ndarray, # time series
                h: int, # forecasting horizon
                future_xreg: np.ndarray, # future regressors
                fitted: bool): # fitted values
    if fitted:
        raise NotImplementedError('return fitted')
    y = X[:, 0] if X.ndim == 2 else X
    mean = croston_classic_(y, h, future_xreg, fitted)
    mean['mean'] *= 0.95
    return mean

# Cell
#@njit
def croston_sba(X: np.ndarray, # time series
                h: int, # forecasting horizon
                future_xreg: np.ndarray, # future regressors
                fitted: bool): # fitted values

    return croston_sba_(X, h, future_xreg, fitted)


# Cell
def imapa(X: np.ndarray, # time series
          h: int, # forecasting horizon
          future_xreg: np.ndarray, # future regressors
          fitted: bool): # fitted values
    if fitted:
        raise NotImplementedError('return fitted')
    y = X[:, 0] if X.ndim == 2 else X
    if (y == 0).all():
        return {'mean': np.repeat(np.float32(0), h)}
    y_intervals = _intervals(y)
    mean_interval = y_intervals.mean().item()
    max_aggregation_level = round(mean_interval)
    forecasts = np.empty(max_aggregation_level, np.float32)
    for aggregation_level in range(1, max_aggregation_level + 1):
        lost_remainder_data = len(y) % aggregation_level
        y_cut = y[lost_remainder_data:]
        aggregation_sums = _chunk_sums(y_cut, aggregation_level)
        forecast, _ = _optimized_ses_forecast(aggregation_sums)
        forecasts[aggregation_level - 1] = (forecast / aggregation_level)
    forecast = forecasts.mean()
    mean = np.repeat(forecast, h)
    return {'mean': mean}

# Internal Cell
@njit
def tsb_(X: np.ndarray, # time series
        h: int, # forecasting horizon
        future_xreg: np.ndarray, # future regressors
        fitted: int, # fitted values
        alpha_d: float,
        alpha_p: float):
    if fitted:
        raise NotImplementedError('return fitted')
    y = X[:, 0] if X.ndim == 2 else X
    if (y == 0).all():
        return {'mean': np.repeat(np.float32(0), h)}
    yd = _demand(y)
    yp = _probability(y)
    ypf, _ = _ses_forecast(yp, alpha_p)
    ydf, _ = _ses_forecast(yd, alpha_d)
    forecast = np.float32(ypf * ydf)
    mean = np.repeat(forecast, h)
    return {'mean': mean}

# Cell
#@njit
def tsb(X: np.ndarray, # time series
        h: int, # forecasting horizon
        future_xreg: np.ndarray, # future regressors
        fitted: int, # fitted values
        alpha_d: float,
        alpha_p: float):

    return tsb_(X, h, future_xreg, fitted, alpha_d, alpha_p)