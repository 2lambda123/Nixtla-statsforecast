# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/tbats.ipynb.

# %% auto 0
__all__ = ['NOGIL', 'CACHE']

# %% ../nbs/tbats.ipynb 1
import math
import os
import numpy as np
import statsmodels.api as sm

from numba import njit
from numpy import linalg as LA
from scipy.stats import norm
from scipy.optimize import minimize_scalar, fmin
from time import time

# %% ../nbs/tbats.ipynb 3
NOGIL = os.environ.get("NUMBA_RELEASE_GIL", "False").lower() in ["true"]
CACHE = os.environ.get("NUMBA_CACHE", "False").lower() in ["true"]

# %% ../nbs/tbats.ipynb 7
@njit(nogil=NOGIL, cache=CACHE)
def guer_cv(lam, x, season_length):
    """
    Minimize this funtion to find the optimal parameter for the Box-Cox transformation.
    """
    period = np.append(season_length, 2)
    period = np.round(np.max(period))
    n = len(x)
    nyears = int(np.floor(n / period))
    nobs = np.floor(nyears * period)
    m = int(n - nobs)
    xmat = x[m:n].reshape((nyears, period))

    xmean = np.full(xmat.shape[0], fill_value=np.nan)
    for k in range(xmat.shape[0]):
        xmean[k] = np.nanmean(xmat[k])

    xsd = np.full(xmat.shape[0], fill_value=np.nan)
    for k in range(xmat.shape[0]):
        vals = xmat[k]
        svar = (vals - np.nanmean(vals)) ** 2
        svar = np.sum(svar) / (len(svar) - 1)  # sample variance
        xsd[k] = np.sqrt(svar)  # sample standard deviation

    xrat = xsd / (xmean ** (1 - lam))

    sd = (xrat - np.nanmean(xrat)) ** 2  # standard deviation
    sd = np.nansum(sd) / (len(sd) - 1)
    sd = np.sqrt(sd)

    return sd / np.nanmean(xrat)

# %% ../nbs/tbats.ipynb 8
def guerrero(x, season_length, lower=-1, upper=2):
    """Finds optimal paramater for Box-Cox transformation using Guerrero's method"""

    if np.any(x < 0):
        raise ValueError(
            "Guerrero's method for selecting a Box-Cox parameter (lambda) is for strictly positive data"
        )

    max_freq = np.max(season_length)
    if len(x) <= 2 * max_freq:
        res = np.array([1])
    else:
        lam = 0  # initial guess
        opt = minimize_scalar(
            guer_cv,
            lam,
            args=(x, season_length),
            method="bounded",
            bounds=(lower, upper),
        )
        res = np.array([opt.x])

    return res

# %% ../nbs/tbats.ipynb 11
@njit(nogil=NOGIL, cache=CACHE)
def BoxCox(y, season_length, BoxCox_lambda):
    """Applies Box-Cox transformation with parameter BoxCox_lambda"""

    if BoxCox_lambda == 0:
        w = np.log(y)
    else:
        w = np.sign(y) * ((np.abs(y) ** BoxCox_lambda) - 1)
        w = w / BoxCox_lambda

    return w

# %% ../nbs/tbats.ipynb 13
@njit(nogil=NOGIL, cache=CACHE)
def InvBoxCox(w, season_length, BoxCox_lambda):
    """Inverts Box-Cox transformation with parameter BoxCox_lambda"""

    if BoxCox_lambda == 0:
        y = np.exp(w)
    else:
        sign = np.sign(BoxCox_lambda * w + 1)
        y = np.abs(BoxCox_lambda * w + 1) ** (1 / BoxCox_lambda)
        y = sign * y

    return y

# %% ../nbs/tbats.ipynb 18
@njit(nogil=NOGIL, cache=CACHE)
def create_x_vector(b, s_vector, d_vector, epsilon_vector):
    l = 0.0
    x = np.array([l])
    if b is not None:
        x = np.append(x, b)
    if s_vector is not None:
        x = np.concatenate((x, s_vector))
    if d_vector is not None:
        x = np.concatenate((x, d_vector))
    if epsilon_vector is not None:
        x = np.concatenate((x, epsilon_vector))

    return x

# %% ../nbs/tbats.ipynb 20
# @njit(nogil=NOGIL, cache=CACHE)
def create_w_matrix(phi, seasonal_periods, ar_coeffs, ma_coeffs):
    numCols = 1
    adjustPhi = 0
    length_seasonal = 0

    if phi is not None:
        adjustPhi = 1
        numCols = numCols + 1
    if seasonal_periods is not None:
        for k in range(len(seasonal_periods)):
            length_seasonal = length_seasonal + seasonal_periods[k]
        numCols = numCols + length_seasonal
    if ar_coeffs is not None:
        p = len(ar_coeffs)
        numCols = numCols + p
    if ma_coeffs is not None:
        q = len(ma_coeffs)
        numCols = numCols + q

    w_transpose = np.zeros((1, numCols))

    if seasonal_periods is not None:
        position = adjustPhi
        for k in range(len(seasonal_periods)):
            position = position + seasonal_periods[k]
            w_transpose[0, position] = 1.0

    w_transpose[0, 0] = 1.0

    if phi is not None:
        w_transpose[0, 1] = phi

    if ar_coeffs is not None:
        for k in range(p):
            w_transpose[0, (adjustPhi + length_seasonal + k + 1)] = ar_coeffs[k]

    if ma_coeffs is not None:
        for k in range(q):
            w_transpose[0, (adjustPhi + length_seasonal + p + k + 1)] = ma_coeffs[k]

    w = np.transpose(w_transpose)

    return w_transpose, w

# %% ../nbs/tbats.ipynb 22
# @njit(nogil=NOGIL, cache=CACHE)
def updateWtransposeMatrix(w_transpose, phi, tau, ar_coeffs, ma_coeffs):
    p, q = findPQ(ar_coeffs, ma_coeffs)
    adjBeta = 0
    if phi is not None:
        adjBeta = 1
        w_transpose[0, 1] = phi
    if p > 0:
        if ar_coeffs is not None:
            for i in range(1, p + 1):
                w_transpose[0, adjBeta + tau + i] = ar_coeffs[i - 1]
        if q > 0:
            if ma_coeffs is not None:
                for i in range(1, q + 1):
                    w_transpose[0, adjBeta + tau + p + i] = ma_coeffs[i - 1]
    elif q > 0:
        if ma_coeffs is not None:
            for i in range(1, q + 1):
                w_transpose[0, adjBeta + tau + i] = ma_coeffs[i - 1]
    return w_transpose

# %% ../nbs/tbats.ipynb 24
# @njit(nogil=NOGIL, cache=CACHE)
def create_g_matrix(alpha, beta, gamma_v, seasonal_periods, ar_coeffs, ma_coeffs):
    numCols = 1
    adjustBeta = 0

    if ar_coeffs is not None:
        p = len(ar_coeffs)
        numCols = numCols + p
    if ma_coeffs is not None:
        q = len(ma_coeffs)
        numCols = numCols + q
    if beta is not None:
        numCols = numCols + 1
        adjustBeta = 1

    gamma_length = 0
    if gamma_v is not None and seasonal_periods is not None:
        for k in range(len(seasonal_periods)):
            gamma_length = gamma_length + seasonal_periods[k]
        numCols = numCols + gamma_length

    g_transpose = np.zeros((1, numCols))
    g_transpose[0, 0] = alpha
    if beta is not None:
        g_transpose[0, 1] = beta
    if gamma_v is not None and seasonal_periods is not None:
        position = adjustBeta + 1
        g_transpose[0, position] = gamma_v[0]
        if len(gamma_v) > 1:
            for k in range(len(gamma_v) - 1):
                position = position + seasonal_periods[k]
                g_transpose[0, position] = gamma_v[k + 1]
    if ar_coeffs is not None:
        g_transpose[0, (adjustBeta + gamma_length + 1)] = 1
    if ma_coeffs is not None:
        g_transpose[0, (adjustBeta + gamma_length + len(ar_coeffs) + 1)] = 1

    gamma_bold_matrix = g_transpose[
        0, (1 + adjustBeta) : (adjustBeta + gamma_length + 1)
    ]

    g = np.transpose(g_transpose)

    return g_transpose, g, gamma_bold_matrix

# %% ../nbs/tbats.ipynb 26
# @njit(nogil=NOGIL, cache=CACHE)
def updateGMatrix(g, gamma_bold_matrix, alpha, beta, gamma_v, seasonal_periods):
    adjBeta = 0
    g[0, 0] = alpha
    if beta is not None:
        g[1, 0] = beta
        adjBeta = 1
    if gamma_bold_matrix is not None and seasonal_periods is not None:
        position = adjBeta + 1
        bPos = 0
        gamma_bold_matrix[bPos] = gamma_v[0]
        g[position, 0] = gamma_v[0]
        if len(gamma_v) > 1:
            for s in range(len(seasonal_periods) - 1):
                position = position + seasonal_periods[s]
                bPos = bPos + seasonal_periods[s]
                g[position, 0] = gamma_v[(s + 1)]
    return g, gamma_bold_matrix

# %% ../nbs/tbats.ipynb 28
# @njit(nogil=NOGIL, cache=CACHE)
def make_F_matrix(
    alpha, beta, phi, seasonal_periods, gamma_bold_matrix, ar_coeffs, ma_coeffs
):
    # 1. Alpha row
    F = np.array([[1.0]])
    if beta is not None:
        F = np.concatenate((F, np.array([phi]).reshape(1, 1)), axis=1)
    if seasonal_periods is not None:
        tau = np.nansum(seasonal_periods)
        zero_tau = np.zeros(tau).reshape(1, tau)
        F = np.concatenate((F, zero_tau), axis=1)
    if ar_coeffs is not None:
        p = len(ar_coeffs)
        alpha_phi = alpha * ar_coeffs
        alpha_phi = alpha_phi.reshape(F.shape[0], alpha_phi.shape[0])
        F = np.concatenate((F, alpha_phi), axis=1)
    if ma_coeffs is not None:
        q = len(ma_coeffs)
        alpha_theta = alpha * ma_coeffs
        alpha_theta = alpha_theta.reshape(F.shape[0], alpha_theta.shape[0])
        F = np.concatenate((F, alpha_theta), axis=1)

    # 2. Beta row
    if beta is not None:
        beta_row = np.array([[0, phi]])
        if seasonal_periods is not None:
            beta_row = np.concatenate((beta_row, zero_tau), axis=1)
        if ar_coeffs is not None:
            beta_phi = beta * ar_coeffs
            beta_phi = beta_phi.reshape(beta_row.shape[0], beta_phi.shape[0])
            beta_row = np.concatenate((beta_row, beta_phi), axis=1)
        if ma_coeffs is not None:
            beta_theta = beta * ma_coeffs
            beta_theta = beta_theta.reshape(beta_row.shape[0], beta_theta.shape[0])
            beta_row = np.concatenate((beta_row, beta_theta), axis=1)
        F = np.concatenate((F, beta_row), axis=0)

    # 3. Seasonal row
    if seasonal_periods is not None:
        seasonal_row = np.transpose(zero_tau)
        if beta is not None:
            seasonal_row = np.concatenate((seasonal_row, seasonal_row), axis=1)

        # Make A matrix
        for k in seasonal_periods:
            if k == seasonal_periods[0]:
                a_row_one = np.zeros((1, k))
                a_row_one[0, (k - 1)] = 1
                a_row_two = np.concatenate(
                    (np.eye(k - 1), np.zeros((k - 1, 1))), axis=1
                )
                A = np.concatenate((a_row_one, a_row_two), axis=0)
            else:
                # This is the case with multiple seasonalities
                old_A_rows = A.shape[0]
                old_A_columns = A.shape[1]
                a_row_one = np.zeros((1, k))
                a_row_one[0, (k - 1)] = 1
                a_row_two = np.concatenate(
                    (np.eye(k - 1), np.zeros((k - 1, 1))), axis=1
                )
                Ak = np.concatenate((a_row_one, a_row_two), axis=0)
                A = np.concatenate((A, np.zeros((Ak.shape[0], old_A_columns))), axis=0)
                A = np.concatenate((A, np.zeros((A.shape[0], Ak.shape[1]))), axis=1)
                A[
                    (old_A_rows) : (old_A_rows + Ak.shape[0]),
                    (old_A_columns) : (old_A_columns + Ak.shape[1]),
                ] = Ak

        seasonal_row = np.concatenate((seasonal_row, A), axis=1)

        if ar_coeffs is not None:
            B = np.outer(gamma_bold_matrix, ar_coeffs)
            seasonal_row = np.concatenate((seasonal_row, B), axis=1)
        if ma_coeffs is not None:
            C = np.outer(gamma_bold_matrix, ma_coeffs)
            seasonal_row = np.concatenate((seasonal_row, C), axis=1)

        F = np.concatenate((F, seasonal_row), axis=0)

    # 4. AR rows
    if ar_coeffs is not None:
        p = len(ar_coeffs)
        ar_rows = np.zeros((p, 1))
        if beta is not None:
            ar_rows = np.concatenate((ar_rows, ar_rows), axis=1)
        if seasonal_periods is not None:
            ar_seasonal_zeros = np.zeros((p, tau))
            ar_rows = np.concatenate((ar_rows, ar_seasonal_zeros), axis=1)
        ident = np.eye(p - 1)
        ident = np.concatenate((ident, np.zeros((p - 1, 1))), axis=1)
        ar_part = np.concatenate(
            (ar_coeffs.reshape(1, ar_coeffs.shape[0]), ident), axis=0
        )
        ar_rows = np.concatenate((ar_rows, ar_part), axis=1)
        if ma_coeffs is not None:
            q = len(ma_coeffs)
            ma_in_ar = np.zeros((p, q))
            ma_in_ar[0, :] = ma_coeffs
            ar_rows = np.concatenate((ar_rows, ma_in_ar), axis=1)
        F = np.concatenate((F, ar_rows), axis=0)

    # 5. MA rows
    if ma_coeffs is not None:
        q = len(ma_coeffs)
        ma_rows = np.zeros((q, 1))
        if beta is not None:
            ma_rows = np.concatenate((ma_rows, ma_rows), axis=1)
        if seasonal_periods is not None:
            ma_seasonal = np.zeros((q, tau))
            ma_rows = np.concatenate((ma_rows, ma_seasonal), axis=1)
        if ar_coeffs is not None:
            ar_in_ma = np.zeros((q, p))
            ma_rows = np.concatenate((ma_rows, ar_in_ma), axis=1)
        ident = np.eye(q - 1)
        ident = np.concatenate((ident, np.zeros((q - 1, 1))), axis=1)
        ma_part = np.concatenate((np.zeros((1, q)), ident), axis=0)
        ma_rows = np.concatenate((ma_rows, ma_part), axis=1)
        F = np.concatenate((F, ma_rows), axis=0)

    return F

# %% ../nbs/tbats.ipynb 30
# @njit(nogil=NOGIL, cache=CACHE)
def updateFMatrix(F, phi, alpha, beta, gamma_bold_matrix, ar_coeffs, ma_coeffs, tau):
    if beta is not None:
        F[0, 1] = phi
        F[1, 1] = phi
        betaAdjust = 1
    else:
        betaAdjust = 0
    p, q = findPQ(ar_coeffs, ma_coeffs)
    if p > 0:
        F[0, (betaAdjust + tau + 1) : (betaAdjust + tau + p + 1)] = alpha * ar_coeffs
        if betaAdjust == 1:
            F[1, (betaAdjust + tau + 1) : (betaAdjust + tau + p + 1)] = beta * ar_coeffs
        if tau > 0:
            B = np.matmul(
                gamma_bold_matrix.reshape((gamma_bold_matrix.shape[0], 1)),
                ar_coeffs.reshape((1, ar_coeffs.shape[0])),
            )
            F[
                (1 + betaAdjust) : (betaAdjust + tau + 1),
                (betaAdjust + tau + 1) : (betaAdjust + tau + p + 1),
            ] = B
        F[
            betaAdjust + tau + 1,
            (betaAdjust + tau + p + 1) : (betaAdjust + tau + p + 1),
        ] = ar_coeffs
    if q > 0:
        F[0, (betaAdjust + tau + p + 1) : (betaAdjust + tau + p + q + 1)] = (
            alpha * ma_coeffs
        )
        if betaAdjust == 1:
            F[1, (betaAdjust + tau + p + 1) : (betaAdjust + tau + p + q + 1)] = (
                beta * ma_coeffs
            )
        if tau > 0:
            C = np.matmul(
                gamma_bold_matrix.reshape((gamma_bold_matrix.shape[0], 1)),
                ma_coeffs.reshape((1, ma_coeffs.shape[0])),
            )
            F[
                (1 + betaAdjust) : (betaAdjust + tau + 1),
                (betaAdjust + tau + p + 1) : (betaAdjust + tau + p + q + 1),
            ] = C
        F[
            betaAdjust + tau + 1,
            (betaAdjust + tau + p + 1) : (betaAdjust + tau + p + q + 1),
        ] = ma_coeffs

    return F

# %% ../nbs/tbats.ipynb 32
# @njit(nogil=NOGIL, cache=CACHE)
def calcModel(data, x_nought, F, g, w, w_transpose):
    n = len(data)
    dimF = F.shape[0]
    x = np.zeros((len(x_nought), n))
    y_hat = np.zeros((1, n))
    e = np.zeros((1, n))
    y_hat[0, 0] = np.matmul(w_transpose, x_nought)
    e[0, 0] = data[0] - y_hat[0, 0]
    x[:, 0] = np.matmul(F, x_nought) + np.transpose(g * e[0, 0])
    data = data.reshape((1, n))

    for k in range(1, n):
        y_hat[0, k] = np.matmul(w_transpose, x[:, k - 1])
        e[0, k] = data[0, k] - y_hat[0, k]
        x[:, k] = (np.matmul(F, x[:, k - 1]).reshape((dimF, 1)) + g * e[0, k]).reshape(
            (dimF,)
        )

    return e, y_hat, x

# %% ../nbs/tbats.ipynb 34
@njit(nogil=NOGIL, cache=CACHE)
def cutW(seasonal_periods, beta, w_tilda_transpose, ar_coeffs, ma_coeffs):
    mask = np.zeros((len(seasonal_periods),), dtype="int")
    n = len(seasonal_periods)

    while n > 1:
        for k in range(n - 1):
            if seasonal_periods[n - 1] % seasonal_periods[k] == 0:
                mask[k] = 1
        n = n - 1
    if len(seasonal_periods) > 1:
        for k in range(len(seasonal_periods), 2):
            for j in range((k - 1), 1):
                hcf = findGCD(seasonal_periods[k], seasonal_periods[j])
                if hcf != 1:
                    if (mask[k] != 1) and (mask[j] != 1):
                        mask[k] = hcf * (-1)

    w_pos_counter = 0
    w_pos = 0

    if beta is not None:
        w_pos = w_pos + 1
    for k in range(len(seasonal_periods)):
        cols = np.arange(0, w_tilda_transpose.shape[1], 1)
        if mask[w_pos_counter] == 1:
            new_cols = np.delete(
                cols, np.arange((w_pos + 1), w_pos + seasonal_periods[k] + 1, 1)
            )
            w_tilda_transpose = w_tilda_transpose[:, new_cols]
        elif mask[w_pos_counter] < 0:
            w_pos = w_pos + seasonal_periods[k]
            new_cols = np.delete(
                cols, np.arange(w_pos, w_pos + mask[w_pos_counter] + 2, 1)
            )
            w_tilda_transpose = w_tilda_transpose[:, new_cols]
        else:
            w_pos = w_pos + seasonal_periods[k]
            new_cols = np.delete(cols, w_pos)
            w_tilda_transpose = w_tilda_transpose[:, new_cols]
            w_pos = w_pos - 1
        w_pos_counter = w_pos_counter + 1

    p, q = findPQ(ar_coeffs, ma_coeffs)

    if p != 0 or q != 0:
        end_cut = w_tilda_transpose.shape[1] - 1
        start_cut = end_cut - (p + q) + 1
        cols = np.arange(0, w_tilda_transpose.shape[1], 1)
        new_cols = np.delete(cols, np.arange(start_cut, end_cut + 1, 1))
        w_tilda_transpose = w_tilda_transpose[:, new_cols]

    return w_tilda_transpose, mask

# %% ../nbs/tbats.ipynb 36
@njit(nogil=NOGIL, cache=CACHE)
def calcSeasonalSeeds(seasonal_periods, beta, ar_coeffs, ma_coeffs, mask, coeffs):
    x_pos_counter = 0
    sum_n = 0
    if beta is not None:
        x_pos = 1
        new_x_nought = coeffs[0:2]
    else:
        x_pos = 0
        new_x_nought = coeffs[0:1]
    new_x_nought = new_x_nought.reshape((len(new_x_nought), 1))
    for k in range(len(seasonal_periods)):
        if mask[x_pos_counter] == 1:
            season = np.zeros((seasonal_periods[k], 1))
            new_x_nought = np.concatenate((new_x_nought, season), axis=0)
        elif mask[x_pos_counter] < 0:
            extract = coeffs[
                (x_pos + 1) : (x_pos + seasonal_periods[k] + mask[x_pos_counter] + 1)
            ]
            n = np.nansum(extract)
            sum_n = sum_n + n / seasonal_periods[k]
            current_periodicity = extract - n / seasonal_periods[k]
            current_periodicity = current_periodicity.reshape(
                (len(current_periodicity), 1)
            )
            additional = np.array([-n / seasonal_periods[k]])
            additional = additional.reshape((1, 1))
            current_periodicity = np.concatenate(
                (current_periodicity, additional), axis=0
            )
            new_x_nought = np.concatenate((new_x_nought, current_periodicity), axis=0)
            x_pos = x_pos + seasonal_periods[k] + mask[x_pos_counter]
        else:
            n = np.nansum(coeffs[(x_pos + 1) : (x_pos + seasonal_periods[k])])
            sum_n = sum_n + n / seasonal_periods[k]
            current_periodicity = (
                coeffs[(x_pos + 1) : (x_pos + seasonal_periods[k])]
                - n / seasonal_periods[k]
            )
            current_periodicity = np.concatenate(
                (current_periodicity, np.array([-n / seasonal_periods[k]])), axis=0
            )
            current_periodicity = current_periodicity.reshape(
                (len(current_periodicity), 1)
            )
            new_x_nought = np.concatenate((new_x_nought, current_periodicity), axis=0)
            x_pos = x_pos + seasonal_periods[k] + 1
        x_pos_counter = x_pos_counter + 1

    # Get the ARMA error seed states if they exist
    p, q = findPQ(ar_coeffs, ma_coeffs)

    if p != 0 or q != 0:
        arma_seed_states = np.zeros((p + q, 1))
        x_nought = np.concatenate((new_x_nought, arma_seed_states), axis=0)
    else:
        x_nought = new_x_nought

    return x_nought

# %% ../nbs/tbats.ipynb 38
# @njit(nogil=NOGIL, cache=CACHE)
def calcBATSFaster(
    ys,
    yHats,
    wTransposes,
    Fs,
    gs,
    e,
    xs,
    xNought_s,
    sPeriods_s,
    betaV,
    tau_s,
    BoxCox_lambda,
    p,
    q,
):
    lengthARMA = p + q

    if sPeriods_s is not None:
        sPeriods = sPeriods_s  # Integer
        lengthSeasonal = len(sPeriods_s)

    if betaV is not None:
        adjBeta = 1
    else:
        adjBeta = 0

    if sPeriods_s is not None:
        # One
        yHats[0, 0] = np.matmul(
            wTransposes[0, 0 : (adjBeta + 1)], xNought_s[0 : (adjBeta + 1), 0]
        )
        previousS = 0
        for i in range(lengthSeasonal):
            yHats[0, 0] = (
                yHats[0, 0] + xNought_s[(previousS + sPeriods[i] + adjBeta), 0]
            )
            previousS = previousS + sPeriods[i]
        if lengthARMA > 0:
            yHats[:, 0] = yHats[0, 0] + np.matmul(
                wTransposes[0, (tau + adjBeta + 1) : (xNought_s.shape[0])],
                xNought_s[(tau + adjBeta + 1) : (xNought_s.shape[0]), 0],
            )

        # Two
        e[0, 0] = ys[0] - yHats[0, 0]

        # Three
        xs[0 : (adjBeta + 1), 0] = np.matmul(
            Fs[0 : (adjBeta + 1), 0 : (adjBeta + 1)], xNought_s[0 : (adjBeta + 1), :]
        ).reshape((xs[0 : (adjBeta + 1), 0].shape[0],))
        if lengthARMA > 0:
            xs[0 : (adjBeta + 1), 0] = xs[0 : (adjBeta + 1), 0] + np.matmul(
                Fs[0 : (adjBeta + 1), (adjBeta + tau + 1) : Fs.shape[1]],
                xNought_s[(adjBeta + tau + 1) : Fs.shape[1]],
            ).reshape((xs[0 : (adjBeta + 1), 0].shape[0],))
        previousS = 0
        for i in range(lengthSeasonal):
            xs[(adjBeta + previousS + 1), 0] = xNought_s[
                (adjBeta + previousS + sPeriods[i]), 0
            ]
            if lengthARMA > 0:
                res = 42
            xs[
                (adjBeta + previousS + 2) : (adjBeta + previousS + sPeriods[i] + 1), 0
            ] = xNought_s[
                (adjBeta + previousS + 1) : (adjBeta + previousS + sPeriods[i]), 0
            ]
            previousS = previousS + sPeriods[i]
        if p > 0:
            xs[(adjBeta + tau + 1), 0] = np.matmul(
                F[(adjBeta + tau + 1), (adjBeta + tau + 1) : (F.shape[1])],
                xNought_s[(adjBeta + tau + 1) : (F.shape[0])],
            )
            if p > 1:
                xs[(adjBeta + tau + 2) : (adjBeta + tau + p + 1), 0] = xNought_s[
                    (adjBeta + tau + 1) : (adjBeta + tau + p)
                ]
        if q > 0:
            xs[(adjBeta + tau + p + 1), 0] = 0
            if q > 1:
                xs[(adjBeta + tau + p + 2) : (adjBeta + tau + p + q), 0] = xNought_s[
                    (adjBeta + tau + p + 1) : (adjBeta + tau + p + q)
                ]

        #####
        xs[0, 0] = xs[0, 0] + gs[0, 0] * e[0, 0]
        if adjBeta == 1:
            xs[1, 0] = xs[1, 0] + gs[1, 0] * e[0, 0]
        previousS = 0
        for i in range(lengthSeasonal):
            xs[(adjBeta + previousS + 1), 0] = (
                xs[(adjBeta + previousS + 1), 0]
                + gs[(adjBeta + previousS + 1), 0] * e[0, 0]
            )
            previousS = previousS + sPeriods[i]
        if p > 0:
            xs[(adjBeta + tau + 1), 0] = xs[(adjBeta + tau + 1), 0] + e[0, 0]
            if q > 0:
                xs[(adjBeta + tau + p + 1), 0] = (
                    xs[(adjBeta + tau + p + 1), 0] + e[0, 0]
                )
        elif q > 0:
            xs[(adjBeta + tau + 1), 0] = xs[(adjBeta + tau + 1), 0] + e[0, 0]
        #####

        for t in range(1, ys.shape[0]):
            yHats[0, t] = np.matmul(
                wTransposes[0, 0 : (adjBeta + 1)], xs[0 : (adjBeta + 1), (t - 1)]
            )
            previousS = 0
            for i in range(lengthSeasonal):
                yHats[0, t] = (
                    yHats[0, t] + xs[(previousS + sPeriods[i] + adjBeta), (t - 1)]
                )
                previousS = previousS + sPeriods[i]
            if lengthARMA > 0:
                yHats[0, t] = yHats[0, t] + np.matmul(
                    wTransposes[0, (tau + adjBeta + 1) : xNought_s.shape[0]],
                    xs[(tau + adjBeta + 1) : xs.shape[0], (t - 1)],
                )
            e[0, t] = ys[t] - yHats[0, t]
            xs[0 : (adjBeta + 1), t] = np.matmul(
                Fs[0 : (adjBeta + 1), 0 : (adjBeta + 1)], xs[0 : (adjBeta + 1), (t - 1)]
            )
            if lengthARMA > 0:
                xs[0 : (adjBeta + 1), t] = xs[0 : (adjBeta + 1), t] + np.matmul(
                    Fs[0 : (adjBeta + 1), (adjBeta + tau + 1) : (Fs.shape[1])],
                    xs[(adjBeta + tau + 1) : Fs.shape[1], (t - 1)],
                )
            previousS = 0
            for i in range(lengthSeasonal):
                xs[(adjBeta + previousS + 1), t] = xs[
                    (adjBeta + previousS + sPeriods[i]), (t - 1)
                ]
                if lengthARMA > 0:
                    xs[(adjBeta + previousS + 1), t] = xs[
                        (adjBeta + previousS + 1), t
                    ] + np.matmul(
                        Fs[
                            (adjBeta + previousS + 1),
                            (adjBeta + tau + 1) : (Fs.shape[1]),
                        ],
                        xs[(adjBeta + tau + 1) : (Fs.shape[1]), (t - q)],
                    )
                xs[
                    (adjBeta + previousS + 2) : (adjBeta + previousS + sPeriods[i] + 1),
                    t,
                ] = xs[
                    (adjBeta + previousS + 1) : (adjBeta + previousS + sPeriods[i]),
                    (t - 1),
                ]
                previousS = previousS + sPeriods[i]
            if p > 0:
                xs[(adjBeta + tau + 1), t] = np.matmul(
                    Fs[(adjBeta + tau + 1), (adjBeta + tau + 1) : Fs.shape[1]],
                    xs[(adjBeta + tau + 1) : Fs.shape[1], (t - 1)],
                )
                if p > 1:
                    xs[(adjBeta + tau + 2) : (adjBeta + tau + p + 1), t] = xs[
                        (adjBeta + tau + 1) : (adjBeta + tau + p), (t - 1)
                    ]
            if q > 0:
                xs[(adjBeta + tau + p + 1), t] = 0
                if q > 1:
                    xs[(adjBeta + tau + p + 2) : (adjBeta + tau + p + q + 1), t] = xs[
                        (adjBeta + tau + p + 1) : (adjBeta + tau + p + q), (t - 1)
                    ]
            xs[0, t] = xs[0, t] + gs[0, 0] * e[0, t]
            if adjBeta == 1:
                xs[1, t] = xs[1, t] + gs[1, 0] * e[0, t]
            previousS = 0
            for i in range(lengthSeasonal):
                xs[(adjBeta + previousS + 1), t] = (
                    xs[(adjBeta + previousS + 1), t]
                    + gs[(adjBeta + previousS + 1), 0] * e[0, t]
                )
                previousS = previousS + sPeriods[i]
            if p > 0:
                xs[(adjBeta + tau + 1), t] = xs[(adjBeta + tau + 1), t] + e[0, t]
                if q > 0:
                    xs[(adjBeta + tau + p + 1), t] = (
                        xs[(adjBeta + tau + p + 1), t] + e[0, t]
                    )
            elif q > 0:
                xs[(adjBeta + tau + 1), t] = xs[(adjBeta + tau + 1), t] + e[0, t]

    return yHats, e

# %% ../nbs/tbats.ipynb 40
def checkAdmisibility(
    BoxCox_lambda, bc_lower_bound, bc_upper_bound, phi, ar_coeffs, ma_coeffs, D
):
    if BoxCox_lambda is not None:
        if (BoxCox_lambda < bc_lower_bound) or (BoxCox_lambda >= bc_upper_bound):
            return False

    if phi is not None:
        if (phi < 0.8) or (phi > 1):
            return False

    if ar_coeffs is not None:
        ar_lags = np.where(np.abs(ar_coeffs) > 1e-8)
        if len(ar_lags) > 0:
            pval = np.max(ar_lags)
            poly = np.polynomial.Polynomial(
                [1] + [-ar_coeffs[i] for i in range(pval + 1)]
            )
            roots = poly.roots()
            if min(np.abs(roots)) < 1 + 1e-2:
                return False

    if ma_coeffs is not None:
        ma_lags = np.where(np.abs(ma_coeffs) > 1e-8)
        if len(ma_lags) > 0:
            qval = np.max(ma_lags)
            poly = np.polynomial.Polynomial(
                [1] + [-ma_coeffs[i] for i in range(qval + 1)]
            )
            roots = poly.roots()
            if min(np.abs(roots)) < 1 + 1e-2:
                return False

    D_eigen_values = LA.eigvals(D)
    return np.all(abs(D_eigen_values) < 1 + 1e-2)

# %% ../nbs/tbats.ipynb 42
def extract_params(
    params,
    seasonal_periods,
    use_boxcox,
    use_trend,
    use_damped_trend,
    use_arma_errors,
    p,
    q,
):
    if use_boxcox:
        BoxCox_lambda = params[0]
        alpha = params[1]
    else:
        alpha = params[0]

    if use_trend and use_damped_trend and use_arma_errors:
        beta = params[2]
        phi = params[3]
        gamma_v = params[4 : 4 + len(seasonal_periods)]
        ar_coeffs = params[4 + len(seasonal_periods) : 4 + len(seasonal_periods) + p]
        ma_coeffs = params[
            4 + len(seasonal_periods) + p : 4 + len(seasonal_periods) + p + q
        ]
    elif use_trend and (not use_damped_trend) and use_arma_errors:
        beta = params[2]
        phi = None
        gamma_v = params[3 : 3 + len(seasonal_periods)]
        ar_coeffs = params[3 + len(seasonal_periods) : 3 + len(seasonal_periods) + p]
        ma_coeffs = params[
            3 + len(seasonal_periods) + p : 3 + len(seasonal_periods) + p + q
        ]
    elif use_trend and (not use_damped_trend) and (not use_arma_errors):
        beta = params[2]
        phi = None
        gamma_v = params[3 : 3 + len(seasonal_periods)]
        ar_coeffs = None
        ma_coeffs = None
    elif (not use_trend) and (not use_damped_trend) and use_arma_errors:
        beta = None
        phi = None
        gamma_v = params[2 : 2 + len(seasonal_periods)]
        ar_coeffs = params[2 + len(seasonal_periods) : 3 + len(seasonal_periods) + p]
        ma_coeffs = params[
            2 + len(seasonal_periods) + p : 3 + len(seasonal_periods) + p + q
        ]
    elif (not use_trend) and (not use_damped_trend) and (not use_arma_errors):
        beta = None
        phi = None
        gamma_v = params[2 : 2 + len(seasonal_periods)]
        ar_coeffs = None
        ma_coeffs = None
    else:
        raise ValueError(
            "use_trend can't be set to False while use_damped_trend is set to True"
        )

    return BoxCox_lambda, alpha, beta, phi, gamma_v, ar_coeffs, ma_coeffs

# %% ../nbs/tbats.ipynb 44
def calcLikelihood(
    params,
    use_boxcox,
    use_trend,
    use_damped_trend,
    use_arma_errors,
    seasonal_periods,
    tau,
    y_trans,
    w_transpose,
    F,
    g,
    gamma_bold_matrix,
    x_nought,
    bc_lower_bound,
    bc_upper_bound,
    p,
    q,
):
    n = len(y_trans)

    yHats = np.zeros((1, n))
    e = np.zeros((1, n))
    xs = np.zeros((len(x_nought), n))

    BoxCox_lambda, alpha, beta, phi, gamma_v, ar_coeffs, ma_coeffs = extract_params(
        params,
        seasonal_periods,
        use_boxcox,
        use_trend,
        use_damped_trend,
        use_arma_errors,
        p,
        q,
    )

    w_transpose = updateWtransposeMatrix(w_transpose, phi, tau, ar_coeffs, ma_coeffs)
    g, gamma_bold_matrix = updateGMatrix(
        g, gamma_bold_matrix, alpha, beta, gamma_v, seasonal_periods
    )
    F = updateFMatrix(F, phi, alpha, beta, gamma_bold_matrix, ar_coeffs, ma_coeffs, tau)

    yHats, es = calcBATSFaster(
        y_trans,
        yHats,
        w_transpose,
        F,
        g,
        e,
        xs,
        x_nought,
        seasonal_periods,
        beta,
        tau,
        BoxCox_lambda,
        p,
        q,
    )

    log_likelihood = n * np.log(np.nansum(es**2)) - 2 * (
        BoxCox_lambda - 1
    ) * np.nansum(np.log(y_trans))
    # print(log_likelihood)

    D = F - matmul(g, w_transpose)

    if checkAdmisibility(
        BoxCox_lambda, bc_lower_bound, bc_upper_bound, phi, ar_coeffs, ma_coeffs, D
    ):
        return log_likelihood
    else:
        return 10**20

    return log_likelihood

# %% ../nbs/tbats.ipynb 46
# @njit(nogil=NOGIL, cache=CACHE)
def matmul(a, b):
    """
    Matrix product of two arrays
    Numba version of numpy.matmul
    DOESN'T WORK WITH ONE DIMENSIONAL NUMPY ARRAYS!
    """
    # if len(a.shape) == 1:
    #     a = a.reshape((a.shape[0], 1))
    # if len(b.shape) == 1:
    #     b = b.reshape((b.shape[0], 1))

    if a.shape[1] != b.shape[0]:
        raise ValueError("Matrix multiplication is not possible")
    else:
        x = np.zeros((a.shape[0], b.shape[1]))
        for i in range(a.shape[0]):
            for j in range(b.shape[1]):
                sum_vals = 0
                for k in range(a.shape[1]):
                    sum_vals = sum_vals + (a[i, k] * b[k, j])
                x[i, j] = sum_vals

    return x

# %% ../nbs/tbats.ipynb 47
@njit(nogil=NOGIL, cache=CACHE)
def findGCD(larger, smaller):
    """
    Find greatest common denominator
    """
    remainder = larger % smaller
    if remainder != 0:
        return findGCD(smaller, remainder)
    else:
        return smaller

# %% ../nbs/tbats.ipynb 48
@njit(nogil=NOGIL, cache=CACHE)
def findPQ(ar_coeffs, ma_coeffs):
    """
    Find the length of the AR coefficients (p)
    and the length of the MA coefficients (q)
    """
    if ar_coeffs is not None:
        p = len(ar_coeffs)
    else:
        p = 0
    if ma_coeffs is not None:
        q = len(ma_coeffs)
    else:
        q = 0
    return p, q

# %% ../nbs/tbats.ipynb 51
def starting_params(
    seasonal_periods, use_trend, use_damped_trend, ar_coeffs, ma_coeffs
):
    if np.nansum(seasonal_periods) > 16:
        alpha = 1e-6
    else:
        alpha = 0.09

    if use_trend:
        b = 0.0
        if np.nansum(seasonal_periods) > 16:
            beta = 5e-7
        else:
            beta = 0.05
        if use_damped_trend:
            phi = 0.999
        else:
            phi = 1
    else:
        b = None
        beta = None
        phi = None

    if seasonal_periods.size == 0:
        gamma_v = None
        s_vector = None
    else:
        gamma_v = np.repeat(0.001, len(seasonal_periods))
        s_vector = np.zeros(np.nansum(seasonal_periods))

    if ar_coeffs is not None:
        d_vector = np.zeros((len(ar_coeffs),))
    else:
        d_vector = None

    if ma_coeffs is not None:
        epsilon_vector = np.zeros((len(ma_coeffs),))
    else:
        epsilon_vector = None

    return alpha, b, beta, phi, gamma_v, s_vector, d_vector, epsilon_vector

# %% ../nbs/tbats.ipynb 53
def bats_model_generator(
    y,
    seasonal_periods,
    use_boxcox,
    bc_lower_bound,
    bc_upper_bound,
    use_trend,
    use_damped_trend,
    use_arma_errors,
    alpha,
    b,
    beta,
    phi,
    gamma_v,
    s_vector,
    d_vector,
    epsilon_vector,
    ar_coeffs,
    ma_coeffs,
):
    n = len(y)
    p, q = findPQ(ar_coeffs, ma_coeffs)

    if use_boxcox:
        BoxCox_lambda = guerrero(
            y, seasonal_periods, lower=bc_lower_bound, upper=bc_upper_bound
        )
        y_trans = BoxCox(y, seasonal_periods, BoxCox_lambda)

    else:
        y_trans = y

    # Set up matrices
    x_nought = create_x_vector(b, s_vector, d_vector, epsilon_vector)

    w_transpose, w = create_w_matrix(phi, seasonal_periods, ar_coeffs, ma_coeffs)

    g_transpose, g, gamma_bold_matrix = create_g_matrix(
        alpha, beta, gamma_v, seasonal_periods, ar_coeffs, ma_coeffs
    )

    F = make_F_matrix(
        alpha, beta, phi, seasonal_periods, gamma_bold_matrix, ar_coeffs, ma_coeffs
    )

    D = F - matmul(g, w_transpose)

    # Find seed states
    y_tilda = calcModel(y_trans, x_nought, F, g, w, w_transpose)[0]

    w_tilda_transpose = np.zeros((len(y_trans), w_transpose.shape[1]))
    w_tilda_transpose[0, :] = w_transpose
    for k in range(1, w_tilda_transpose.shape[0]):
        w_tilda_transpose[k, :] = np.matmul(w_tilda_transpose[k - 1, :], D)

    if seasonal_periods is not None:
        w_tilda_transpose, mask = cutW(
            seasonal_periods, beta, w_tilda_transpose, ar_coeffs, ma_coeffs
        )

        model = sm.OLS(y_tilda.reshape((y_tilda.shape[1], 1)), w_tilda_transpose).fit()
        coeffs = model.params

        x_nought = calcSeasonalSeeds(
            seasonal_periods, beta, ar_coeffs, ma_coeffs, mask, coeffs
        )
    else:
        if p != 0 or q != 0:
            end_cut = w_tilda_transpose.shape[1]
            start_cut = end_cut - (p + q)
            cols = np.arange(0, w_tilda_transpose.shape[1], 1)
            new_cols = np.delete(cols, np.arange(start_cut, end_cut, 1))
            w_tilda_transpose = w_tilda_transpose[:, new_cols]
        model = sm.OLS(y_tilda.reshape((y_tilda.shape[1], 1)), w_tilda_transpose).fit()
        x_nought = model.params
        if p != 0 or q != 0:
            arma_seed_states = np.zeros((p + q,))
            x_nought = np.concatenate((x_nought, arma_seed_states))
        x_nought = x_nought.reshape((x_nought.shape[0], 1))

    # Minimize log-likelihood to find optimal parameters
    if seasonal_periods is not None:
        tau = np.nansum(seasonal_periods)
    else:
        tau = 0

    # Create vector with parameters
    if use_boxcox:
        params = np.concatenate([BoxCox_lambda, np.array([alpha])])
    else:
        params = np.array([alpha])
    if beta is not None:
        params = np.concatenate([params, np.array([beta])])
    if phi is not None:
        params = np.concatenate([params, np.array([phi])])
    params = np.concatenate([params, gamma_v])
    if ar_coeffs is not None:
        params = np.concatenate([params, ar_coeffs])
    if ma_coeffs is not None:
        params = np.concatenate([params, ma_coeffs])

    # Solve optimization problem
    start = time()
    optim_params = fmin(
        calcLikelihood,
        params,
        args=(
            use_boxcox,
            use_trend,
            use_damped_trend,
            use_arma_errors,
            seasonal_periods,
            tau,
            y_trans,
            w_transpose,
            F,
            g,
            gamma_bold_matrix,
            x_nought,
            bc_lower_bound,
            bc_upper_bound,
            p,
            q,
        ),
        maxiter=2000,
    )
    end = time()
    print("Total execution time: " + str((end - start) / 60))

    # Extract optimal parameters
    (
        optim_BoxCox_lambda,
        optim_alpha,
        optim_beta,
        optim_phi,
        optim_gamma_v,
        optim_ar_coeffs,
        optim_ma_coeffs,
    ) = extract_params(
        optim_params,
        seasonal_periods,
        use_boxcox,
        use_trend,
        use_damped_trend,
        use_arma_errors,
        p,
        q,
    )

    x_nought_untransformed = InvBoxCox(x_nought, seasonal_periods, params[0])
    xx_nought = BoxCox(x_nought_untransformed, seasonal_periods, optim_BoxCox_lambda)
    xx_nought = xx_nought.reshape((xx_nought.shape[0],))

    # Re-set up the matrices
    w_transpose, w = create_w_matrix(
        optim_phi, seasonal_periods, optim_ar_coeffs, optim_ma_coeffs
    )

    g_transpose, g, gamma_bold_matrix = create_g_matrix(
        optim_alpha,
        optim_beta,
        optim_gamma_v,
        seasonal_periods,
        optim_ar_coeffs,
        optim_ma_coeffs,
    )

    F = make_F_matrix(
        optim_alpha,
        optim_beta,
        optim_phi,
        seasonal_periods,
        gamma_bold_matrix,
        optim_ar_coeffs,
        optim_ma_coeffs,
    )

    if use_boxcox:
        y_trans = BoxCox(y, seasonal_periods, optim_BoxCox_lambda)
        e, fitted, x = calcModel(y_trans, xx_nought, F, g, w, w_transpose)
        variance = np.nansum((e * e)) / len(y_trans)
        fitted_values = InvBoxCox(fitted, seasonal_periods, optim_BoxCox_lambda)
    else:
        e, fitted, x = calcModel(y_trans, xx_nought, F, g, w, w_transpose)
        variance = np.nansum((e * e)) / len(y_trans)

    # Calculate likelihood
    likelihood = len(y) * np.log(np.nansum(e**2)) - 2 * (
        optim_BoxCox_lambda - 1
    ) * np.nansum(np.log(y))

    # Calculate AIC
    aic = likelihood + 2 * (len(optim_params) + x_nought.shape[0])

    res = {
        "e": e,
        "fitted_values": fitted_values,
        "variance": variance,
        "aic": aic,
        "optim_params": optim_params,
        "F": F,
        "w_transpose": w_transpose,
        "g": g,
        "x": x,
    }

    return res

# %% ../nbs/tbats.ipynb 55
def bats_model(
    y,
    seasonal_periods,
    use_boxcox,
    bc_lower_bound,
    bc_upper_bound,
    use_trend,
    use_damped_trend,
    use_arma_errors,
):
    seasonal_periods = np.sort(seasonal_periods)

    # Check if there are missing values
    indices = np.where(np.isnan(y))[0]
    if len(indices) > 0:
        max_index = indices[-1]
        y = y[max_index + 1 : len(y)]

    # Check if there are negative values
    if np.any(y < 0):
        use_boxcox = False

    # Create first model
    ar_coeffs = None
    ma_coeffs = None
    p, q = findPQ(ar_coeffs, ma_coeffs)

    # Starting parameters
    alpha, b, beta, phi, gamma_v, s_vector, d_vector, epsilon_vector = starting_params(
        seasonal_periods, use_trend, use_damped_trend, ar_coeffs, ma_coeffs
    )

    model1 = bats_model_generator(
        y,
        seasonal_periods,
        use_boxcox,
        bc_lower_bound,
        bc_upper_bound,
        use_trend,
        use_damped_trend,
        use_arma_errors,
        alpha,
        b,
        beta,
        phi,
        gamma_v,
        s_vector,
        d_vector,
        epsilon_vector,
        ar_coeffs,
        ma_coeffs,
    )
    best_model = model1

    if use_arma_errors:
        # ARMA errors from first model
        errors = res["e"][0]
        auto_arima = AutoARIMA(season_length=12, d=0)
        fit = auto_arima.fit(errors)
        p = int(arima_string(fit.model_)[6])
        q = int(arima_string(fit.model_)[8])
        if p != 0:
            ar_coeffs = np.zeros((p,))
        else:
            ar_coeffs = None
        if q != 0:
            ma_coeffs = np.zeros((q,))
        else:
            ma_coeffs = None

        (
            optim_BoxCox_lambda,
            optim_alpha,
            optim_beta,
            optim_phi,
            optim_gamma_v,
            optim_ar_coeffs,
            optim_ma_coeffs,
        ) = extract_params(
            optim_params,
            seasonal_periods,
            use_boxcox,
            use_trend,
            use_damped_trend,
            use_arma_errors,
            p,
            q,
        )
        model2 = bats_model_generator(
            y,
            seasonal_periods,
            use_boxcox,
            bc_lower_bound,
            bc_upper_bound,
            use_trend,
            use_damped_trend,
            use_arma_errors,
            optim_alpha,
            b,
            optim_beta,
            optim_phi,
            optim_gamma_v,
            s_vector,
            d_vector,
            epsilon_vector,
            ar_coeffs,
            ma_coeffs,
        )

        if model2["aic"] < model1["aic"]:
            best_model = model2

    return best_model

# %% ../nbs/tbats.ipynb 58
def bats_forecast(mod, h, use_boxcox, seasonal_periods):
    fcst = np.zeros((h,))
    xx = np.zeros((mod["x"].shape[0], h))

    fcst[0] = np.matmul(mod["w_transpose"], mod["x"][:, -1])

    xx[:, 0] = np.matmul(mod["F"], mod["x"][:, -1])

    if h > 1:
        for t in range(1, h):
            xx[:, t] = np.matmul(mod["F"], xx[:, (t - 1)])
            fcst[t] = np.matmul(mod["w_transpose"], xx[:, (t - 1)])

    if use_boxcox:
        optim_BoxCox_lambda = mod["optim_params"][0]
        fcst = InvBoxCox(fcst, seasonal_periods, optim_BoxCox_lambda)

    return fcst
